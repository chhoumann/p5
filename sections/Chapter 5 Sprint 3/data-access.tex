\subsection{Object Relational Mapping}
An Object Relational Mapping (ORM) is often used in an application to connect to and manipulate data on a database.

The primary requirement for the choice of an ORM was fast implementation and ease of use due to the timeline constraints that were imposed by the \knox{} project. 

\subsubsection{Dapper}
Dapper is an open source Micro ORM. It is a mapping framework that helps mapping the result from a native query to a class with the same attributes as the tables. Dapper is a lightweight framework made for developers that emphasizes using stored procedures or native query language over using a large scale ORM tool. 


Dapper, when added to projects, extends the \texttt{IDbConnection} inferface. This extension adds helper methods. 
One of the helpers is the \texttt{Query} method. This method will take an SQL query as a parameter and return a list. The returned list can either be strongly or dynamically typed.
Another helper that is added to \texttt{IDbConnection} is the \texttt{Execute} method. This method takes one or more SQL commands as a parameter and has no return type. When called, the commands passed to the method will be executed. The \texttt{Execute} method can also be used to execute commands multiple times\cite{Dapper_Git}.

Dapper's simple approach to ORM's means that a large part of the standard features have been dropped. This means that Dappers focuses on being a lightweight and efficient framework that should cover most of the users needs over being a fullfledge ORM \cite{Dapper_Git}.

This means that Dapper as a framework covers our usecases with the caveat that additional time is going to be needed in order to fullfil the sprints MVP. 

\subsubsection{Entity Framework Core}
The second technology that we considered was Entity Framework Core (EF Core), which is a data access technology developed by Microsoft for the .NET platform. EF Core can serve as an object-relational mapper \cite{Object_relational_mapping} which lets developers abstract away the complications of converting data to .NET objects, in addition to eliminating the majority of the data-access code that would typically have to be written.

EF Core uses models to create the data access. A model is composed of entity classes and a context object representing a database session.
Queries are then able to be performed through the context object. 
The use case for EF Core is that, it is a fast way of implementing data access without the need for as much manual implementation as with Dapper. 
The drawback of EF Core is that the learning curve is steep, and one must be at least an intermediate level user of the framework to avoid common security and performance pitfalls \cite{EFCore}.

Due to previous experience with the framework among group members, we had the ability to quickly implement EF Core and fulfill the use cases that we had.
With this in mind, we concluded that we were better able to accommodate for the tight deadline using EF Core to fulfill the required features for the \knox{} project.
