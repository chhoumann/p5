\section{Validation}

As previously mentioned in section \ref{databaseResponsibility}, the knowledge layer posts data to the database that later need to be fetched by the functionality layer.

To ensure that the data being posted is correct, we have developed a validation method in collaboration with the knowledge layer.
To validate JSON files recieved from the knowledge layer, one must develop a JSON schema that specifies a structure that a JSON file can be checked against.

We created a new controller called \texttt{SchemaController} which is responsible for posting JSON schemas to the database. 
Currently, only one schema is stored in the database, however the system is developed such that it is scalable and expandable.

In the WordCount controller, the \texttt{POST} method first fetches the JSON schema from the database.
A new object of type \texttt{JsonValidator} is then instantiated, and its \texttt{IsValid} method is then used to determine whether the input conforms to the structure defined within the given schema. 
The method returns true if the JSON object follows the schema, and false if it does not.
The class is generic, allowing reusability for all types, and it is implemented using the Newtonsoft JSON framework. 

This can be seen in code snippet \ref{lst:json_post}.

\begin{lstlisting}[language=CSharp, caption={Snippet from the \texttt{POST} method showing validation of the input JSON.}, label={lst:json_post}]
[HttpPost]
public IActionResult Post([FromBody] JsonElement jsonElement)
{
	JsonSchemaModel? schema = unitOfWork.SchemaRepository.Find(s => s.SchemaName == WordCountSchemaName);
	
	\dots

	// Get schema and use for validating
	if (!new JsonValidator<ArticleJsonModel[]>(schema.JsonString)
		.IsValid(jsonInput, out ArticleJsonModel[] jsonArticles))
	{
		return BadRequest("Wrong body syntax, does not follow schema.");
	}
}
\end{lstlisting}

The \texttt{IsValid} method first checks whether the provided JSON string matches the provided JSON schema.
If so, it simply deserializes the JSON string into the class provided by the generic constraint.
This is captured in code snippet \ref{jsonIsValid}.

\begin{lstlisting}[language=CSharp, caption={The \texttt{IsValid} method from the \texttt{JsonValidator} class.}, label={lst:jsonIsValid}]
public bool IsValid(string jsonString, out T data)
{
	JToken jToken = JToken.Parse(jsonString);

	data = null;

	if (!jToken.IsValid(schema))
	{
		return false;
	}

	data = DeserializeJsonString(jsonString);

	return true;
}
\end{lstlisting}

If the result is valid, the deserialized object is returned as an \texttt{out} parameter for use by the caller.
