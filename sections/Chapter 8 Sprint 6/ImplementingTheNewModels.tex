\subsubsection*{Implementing the models}

Having established the quality of the design of the database structures, we will now how they are implemented. 
Since the relation representing a publisher has not been changed, we will not implement any new designs to it. 
When creating the new tables, we ensure that no loss of data occurs, simply by not dropping the old tables, and renaming them instead. 
The tables can then be dropped later after the full implementations of the new design have been performed.
The renaming of the tables can be seen in Code Snippet \ref{lst:RenamingOldModelsSQL}.

\begin{lstlisting}[
    label=lst:RenamingOldModelsSQL,
    language=SQL,
    caption=SQL script renaming the existing database structures,
    showspaces=false,
    numbers=left,
    numberstyle=\tiny,
    commentstyle=\color{gray},
    escapechar=|
 ]
 ALTER TABLE "Article"
    RENAME TO "Article_Redundant";
ALTER TABLE "Term"
    RENAME TO "Term_Redundant";
\end{lstlisting}

When implementing the new tables, we base them on the just-renamed tables from the old database design.
By doing this, we ensure that all data from the old tables are correctly transferred to the new ones since each of the commands is a transaction. (see section \ref{relational_databases}).
After all data have been transferred to a new table, constraints, foreign- and primary keys are added to the tables. 
This is seen on Code Snippet \ref{lst:CreatingTheNewDBModelsSQL}.
We have ensured that the changes are reversible by creating a script dropping the new tables, and restoring the structure of the old tables.
The script is found in Appendix \ref{SQLBackupScript}.

\begin{lstlisting}[
    label=lst:CreatingTheNewDBModelsSQL,
    language=SQL,
    caption=SQL script creating the tables described in \ref{databaseModelRedesignNF}. Foreign- and primary key constraints are also defined.,
    showspaces=false,
    numbers=left,
    numberstyle=\tiny,
    commentstyle=\color{gray},
    escapechar=|
 ]
CREATE TABLE "Article" AS
SELECT * FROM "Article_Redundant";
ALTER TABLE "Article"
    ADD CONSTRAINT "Id_PRMK" PRIMARY KEY ("Id"),
    ADD FOREIGN KEY ("PublisherName") REFERENCES "Publisher"("PublisherName");

CREATE TABLE "Word" AS
SELECT DISTINCT t."Word" AS "Text" FROM "Term_Redundant" t;
ALTER TABLE "Word" ADD CONSTRAINT "Literal_PRMK" PRIMARY KEY ("Text");

CREATE TABLE "OccursIn" AS
    (
        SELECT "art"."Id" as "ArticleId", "t"."Count",  t."Word"
        FROM"Term_Redundant" t JOIN wordcount.public."Article_Redundant" art ON t."ArticleId" = art."Id"
    );
ALTER TABLE "OccursIn"
    ADD FOREIGN KEY ("ArticleId") REFERENCES "Article"("Id"),
    ADD FOREIGN KEY ("Word") REFERENCES "Word"("Text"),
    ADD PRIMARY KEY ("ArticleId", "Word");
\end{lstlisting}

Having implemented the new database structures, we can redefine the WordRatio view.
Notice that the view is replaceable without loss of data since it is an abstraction over a \texttt{SELECT} statement.
\begin{lstlisting}[
    label=lst:DefiningNewView,
    language=SQL,
    caption=SQL script defining a new WordRatio view.,
    showspaces=false,
    numbers=left,
    numberstyle=\tiny,
    commentstyle=\color{gray},
    escapechar=|
 ]
CREATE OR REPLACE view "WordRatio"("ArticleId", "Word", "Count", "Title", "FilePath", "TotalWords", "PublisherName", "Percent") as
SELECT "OccursIn"."ArticleId",
       "OccursIn"."Word",
       "OccursIn"."Count",
       "Article"."Title",
       "Article"."FilePath",
       "Article"."TotalWords",
       "Article"."PublisherName",
       round("OccursIn"."Count"::numeric / "Article"."TotalWords"::numeric * 100::numeric, 2) AS "Percent"
FROM "Article"
         JOIN "OccursIn" ON "OccursIn"."ArticleId" = "Article"."Id"
         JOIN "Publisher" ON "Article"."PublisherName" = "Publisher"."PublisherName";
\end{lstlisting}
