\subsubsection*{Implementing the models}\label{implementing_new_WC_DB_models}
Having established the quality of the design of the database structures, we will now implement them.
When creating the new tables, we ensure that no loss of data occurs by not dropping the old tables, and instead renaming them. 
The tables can then be dropped later after the full implementations of the new design have been performed.
The renaming of the tables can be seen in code snippet \ref{lst:RenamingOldModelsSQL}.

\begin{lstlisting}[
    label=lst:RenamingOldModelsSQL,
    language=SQL,
    caption=SQL script renaming the existing database structures,
    showspaces=false,
    numbers=left,
    numberstyle=\tiny,
    commentstyle=\color{gray},
    escapechar=|
 ]
 ALTER TABLE "Article"
    RENAME TO "Article_Redundant";
ALTER TABLE "Term"
    RENAME TO "Term_Redundant";
\end{lstlisting}

When implementing the new tables, we base them on the just-renamed tables from the old database design.
By doing this, we ensure that all data from the old tables are correctly transferred to the new ones, since each of the commands is a transaction (see section \ref{relational_databases}).
After all data have been transferred to a new table, constraints, foreign- and primary keys are added to the tables. 
This can be seen on code snippet \ref{lst:CreatingTheNewDBModelsSQL}.
We have ensured that the changes are reversible by creating a script dropping the new tables, and restoring the structure of the old tables.
The script is found in Appendix \ref{SQLBackupScript}.

\begin{lstlisting}[
    label=lst:CreatingTheNewDBModelsSQL,
    language=SQL,
    caption=SQL script creating the tables described in \ref{databaseModelRedesignNF}. Foreign- and primary key constraints are also defined.,
    showspaces=false,
    numbers=left,
    numberstyle=\tiny,
    commentstyle=\color{gray},
    escapechar=|
 ]
CREATE TABLE "Article" AS
SELECT * FROM "Article_Redundant";
ALTER TABLE "Article"
    ADD CONSTRAINT "Id_PRMK" PRIMARY KEY ("Id"),
    ADD FOREIGN KEY ("PublisherName") REFERENCES "Publisher"("PublisherName");

CREATE TABLE "Word" AS
SELECT DISTINCT t."Word" AS "Text" FROM "Term_Redundant" t;
ALTER TABLE "Word" ADD CONSTRAINT "Literal_PRMK" PRIMARY KEY ("Text");

CREATE TABLE "OccursIn" AS
    (
        SELECT "art"."Id" as "ArticleId", "t"."Count",  t."Word"
        FROM"Term_Redundant" t JOIN wordcount.public."Article_Redundant" art ON t."ArticleId" = art."Id"
    );
ALTER TABLE "OccursIn"
    ADD FOREIGN KEY ("ArticleId") REFERENCES "Article"("Id"),
    ADD FOREIGN KEY ("Word") REFERENCES "Word"("Text"),
    ADD PRIMARY KEY ("ArticleId", "Word");
\end{lstlisting}

Having implemented the new database structures, we can redefine the WordRatio view.
Notice that the view is an abstraction over a \texttt{SELECT} statement, thus it is replaceable without loss of data.


\begin{lstlisting}[
    label=lst:DefiningNewView,
    language=SQL,
    caption=SQL script defining a new WordRatio view.,
    showspaces=false,
    numbers=left,
    numberstyle=\tiny,
    commentstyle=\color{gray},
    escapechar=|
 ]
CREATE OR REPLACE view "WordRatio"("ArticleId", "Word", "Count", "Title", "FilePath", "TotalWords", "PublisherName", "Percent") as
SELECT "OccursIn"."ArticleId",
       "OccursIn"."Word",
       "OccursIn"."Count",
       "Article"."Title",
       "Article"."FilePath",
       "Article"."TotalWords",
       "Article"."PublisherName",
       round("OccursIn"."Count"::numeric / "Article"."TotalWords"::numeric * 100::numeric, 2) AS "Percent"
FROM "Article"
         JOIN "OccursIn" ON "OccursIn"."ArticleId" = "Article"."Id"
         JOIN "Publisher" ON "Article"."PublisherName" = "Publisher"."PublisherName";
\end{lstlisting}
